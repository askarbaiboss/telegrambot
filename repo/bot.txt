import os
import sys
import json
import sqlite3
from dotenv import load_dotenv
from datetime import time

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
)

# ================= LOAD ENV =================
load_dotenv()
TOKEN = os.getenv("BOT_TOKEN")
if not TOKEN:
    print("‚ùå BOT_TOKEN not set.")
    sys.exit(1)

ADMIN_ID = 165665465
DB_NAME = "orders.db"
user_data_store = {}

# ================= LOAD PRODUCTS =================
def load_products():
    try:
        with open("products.json", "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"‚ùå Error loading products.json: {e}")
        sys.exit(1)

products = load_products()

# ================= DATABASE =================
def get_connection():
    return sqlite3.connect(DB_NAME)

def init_db():
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS orders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                product_name TEXT,
                product_link TEXT,
                quantity INTEGER,
                customer_name TEXT,
                order_number TEXT,
                payment_method TEXT,
                payment_info TEXT,
                review_sent INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()

def save_order(user_id, data):
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO orders 
            (user_id, product_name, product_link, quantity, customer_name, order_number)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            user_id,
            data["product_name"],
            data["product_link"],
            data["quantity"],
            data["customer_name"],
            data["order_number"]
        ))
        conn.commit()
        return cursor.lastrowid

def update_payment(order_id, method, info):
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE orders 
            SET payment_method=?, payment_info=? 
            WHERE id=?
        """, (method, info, order_id))
        conn.commit()

def mark_review_sent(order_id):
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("UPDATE orders SET review_sent=1 WHERE id=?", (order_id,))
        conn.commit()

def get_user_orders(user_id):
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, product_name, quantity, created_at
            FROM orders
            WHERE user_id=?
            ORDER BY created_at DESC
        """, (user_id,))
        return cursor.fetchall()

def get_orders_pending_review():
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT id, user_id, product_name FROM orders WHERE review_sent=0")
        return cursor.fetchall()

def get_all_orders():
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, user_id, product_name, product_link, quantity, customer_name, order_number, payment_method, payment_info, review_sent, created_at
            FROM orders
            ORDER BY created_at DESC
        """)
        return cursor.fetchall()

def get_stats():
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM orders")
        total_orders = cursor.fetchone()[0]

        cursor.execute("SELECT SUM(quantity) FROM orders")
        total_quantity = cursor.fetchone()[0] or 0

        return total_orders, total_quantity

init_db()

# ================= COMMANDS =================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data_store[user_id] = {}

    keyboard = [[InlineKeyboardButton(p["name"], callback_data=f"product_{p['name']}")] for p in products]
    await update.message.reply_text("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ! –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à –∑–∞–∫–∞–∑:", reply_markup=InlineKeyboardMarkup(keyboard))

async def my_orders(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    orders = get_user_orders(user_id)
    if not orders:
        await update.message.reply_text("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–∫–∞–∑–æ–≤.")
        return

    message = "üì¶ –í–∞—à–∏ –∑–∞–∫–∞–∑—ã:\n\n"
    for order in orders:
        message += f"ID: {order[0]}\n–¢–æ–≤–∞—Ä: {order[1]}\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {order[2]}\n–î–∞—Ç–∞: {order[3]}\n\n"
    await update.message.reply_text(message)

async def all_orders(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return

    orders = get_all_orders()
    if not orders:
        await update.message.reply_text("–ù–µ—Ç –∑–∞–∫–∞–∑–æ–≤.")
        return

    message = "üìä –í—Å–µ –∑–∞–∫–∞–∑—ã —Å –ø–æ–ª–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∫–ª–∏–µ–Ω—Ç–æ–≤:\n\n"
    for order in orders:
        message += (
            f"ID: {order[0]}\nUser ID: {order[1]}\n–¢–æ–≤–∞—Ä: {order[2]}\n–°—Å—ã–ª–∫–∞: {order[3]}\n"
            f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {order[4]}\n–ò–º—è –∫–ª–∏–µ–Ω—Ç–∞: {order[5] or '‚Äî'}\n–ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞: {order[6] or '‚Äî'}\n"
            f"–ú–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã: {order[7] or '‚Äî'}\n–î–∞–Ω–Ω—ã–µ –æ–ø–ª–∞—Ç—ã: {order[8] or '‚Äî'}\n"
            f"–û—Ç–∑—ã–≤ –ø–æ–ª—É—á–µ–Ω: {'‚úÖ' if order[9] else '‚ùå'}\n–î–∞—Ç–∞: {order[10]}\n\n"
        )

    for chunk in [message[i:i+4000] for i in range(0, len(message), 4000)]:
        await update.message.reply_text(chunk)

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return

    total_orders, total_quantity = get_stats()
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT payment_method, COUNT(*) FROM orders
            WHERE payment_method IS NOT NULL
            GROUP BY payment_method
        """)
        payment_counts = cursor.fetchall()
    payment_summary = "\n".join([f"{row[0]}: {row[1]}" for row in payment_counts]) or "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ–± –æ–ø–ª–∞—Ç–µ."

    await update.message.reply_text(
        f"üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n–í—Å–µ–≥–æ –∑–∞–∫–∞–∑–æ–≤: {total_orders}\n–í—Å–µ–≥–æ –ø—Ä–æ–¥–∞–Ω–æ —Ç–æ–≤–∞—Ä–æ–≤: {total_quantity}\n–û–ø–ª–∞—Ç—ã:\n{payment_summary}"
    )

# ================= CALLBACK =================
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    data = user_data_store.setdefault(user_id, {})

    if query.data.startswith("product_"):
        product_name = query.data.replace("product_", "")
        product = next((p for p in products if p["name"] == product_name), None)
        if not product:
            await query.edit_message_text("–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        data["product_name"] = product["name"]
        data["product_link"] = product["link"]
        await query.message.reply_text(f"üîó –°—Å—ã–ª–∫–∞ –Ω–∞ —Ç–æ–≤–∞—Ä:\n{product['link']}")
        await query.message.reply_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏: {product_name}\n–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ:")

    elif query.data in ["zelle", "venmo"]:
        data["payment_method"] = query.data.capitalize()
        data["awaiting_payment_info"] = True
        await query.edit_message_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ {data['payment_method']}.\n–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã:")

    elif query.data == "cancel":
        user_data_store[user_id] = {}
        await query.edit_message_text("‚ùå –ó–∞–∫–∞–∑ –æ—Ç–º–µ–Ω—ë–Ω.")

# ================= MESSAGE HANDLER =================
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    data = user_data_store.setdefault(user_id, {})

    # ===== Detect screenshot (photo) =====
    if update.message.photo:
        # Get the latest order for this user that hasn't sent a review
        with get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id FROM orders
                WHERE user_id=? AND review_sent=0
                ORDER BY created_at DESC LIMIT 1
            """, (user_id,))
            order = cursor.fetchone()
            if order:
                order_id = order[0]
                
                # Create folder if it doesn't exist
                os.makedirs("reviews", exist_ok=True)
                
                # Download the photo locally (highest resolution)
                file = await update.message.photo[-1].get_file()
                file_path = f"reviews/review_{user_id}_{order_id}.jpg"
                await file.download_to_drive(file_path)

                # Mark review as received
                mark_review_sent(order_id)
                await update.message.reply_text("–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∑—ã–≤! ‚úÖ")
                print(f"–°–æ—Ö—Ä–∞–Ω—ë–Ω —Å–∫—Ä–∏–Ω—à–æ—Ç: {file_path}")
        return  # stop further processing for this message

    # ===== Process text messages =====
    text = update.message.text.strip() if update.message.text else ""

    # Ensure order started
    if "product_name" not in data:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start")
        return

    # Handle payment info
    if data.get("awaiting_payment_info"):
        update_payment(data["order_id"], data["payment_method"], text)
        await context.bot.send_message(
            ADMIN_ID,
            f"üí∞ –û–ø–ª–∞—Ç–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞\nID: {data['order_id']}\n–ú–µ—Ç–æ–¥: {data['payment_method']}\n–î–∞–Ω–Ω—ã–µ: {text}"
        )
        await update.message.reply_text("‚úÖ –û–ø–ª–∞—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.")
        user_data_store[user_id] = {}
        # Immediately ask for review if not already asked
        await update.message.reply_text(
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –≤–∞—à–µ–≥–æ –æ—Ç–∑—ã–≤–∞ –¥–ª—è —Ç–æ–≤–∞—Ä–∞: {data.get('product_name', '‚Äî')} ‚úÖ"
        )
        return

    # Collect order details
    if "quantity" not in data:
        if not text.isdigit() or int(text) <= 0:
            await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
            return
        data["quantity"] = int(text)
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –ø–æ–ª–Ω–æ–µ –∏–º—è:")
        return

    if "customer_name" not in data:
        data["customer_name"] = text
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞ Amazon:")
        return

    if "order_number" not in data:
        data["order_number"] = text
        order_id = save_order(user_id, data)
        data["order_id"] = order_id

        await context.bot.send_message(
            ADMIN_ID,
            f"üì¶ –ù–æ–≤—ã–π –∑–∞–∫–∞–∑\nID: {order_id}\n–ü—Ä–æ–¥—É–∫—Ç: {data['product_name']}\n–ö–æ–ª-–≤–æ: {data['quantity']}"
        )

        # Ask for review immediately
        await update.message.reply_text(
            f"–°–ø–∞—Å–∏–±–æ –∑–∞ –∑–∞–∫–∞–∑! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –≤–∞—à–µ–≥–æ –æ—Ç–∑—ã–≤–∞ –¥–ª—è —Ç–æ–≤–∞—Ä–∞: {data['product_name']} ‚úÖ"
        )

        # Payment buttons
        keyboard = [
            [InlineKeyboardButton("Zelle", callback_data="zelle"), InlineKeyboardButton("Venmo", callback_data="venmo")],
            [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel")]
        ]
        await update.message.reply_text(
            "–ö–∞–∫ —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –æ–ø–ª–∞—Ç—É?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
# ================= DAILY REVIEW REMINDER =================
async def review_reminder(context: ContextTypes.DEFAULT_TYPE):
    orders = get_orders_pending_review()
    for order_id, user_id, product_name in orders:
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text=f"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –≤–∞—à–µ–≥–æ –æ—Ç–∑—ã–≤–∞ –¥–ª—è —Ç–æ–≤–∞—Ä–∞: {product_name} ‚úÖ"
            )
        except Exception as e:
            print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")

# ================= RUN =================
if __name__ == "__main__":
    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("myorders", my_orders))
    app.add_handler(CommandHandler("allorders", all_orders))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(MessageHandler(filters.PHOTO, handle_message))

    # Daily reminders
    app.job_queue.run_daily(review_reminder, time=time(10, 0))
    app.job_queue.run_daily(review_reminder, time=time(18, 0))

    print("‚úÖ Bot running...")
    app.run_polling()